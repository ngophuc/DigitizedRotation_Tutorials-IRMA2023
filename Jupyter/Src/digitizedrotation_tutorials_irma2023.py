# -*- coding: utf-8 -*-
"""DigitizedRotation_Tutorials-IRMA2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10g2PevIzVlftpVdIoEXXbgON1fKytJV6

# Tutorials for Summer school: "[Geometry and Data](https://indico.math.cnrs.fr/event/9939/)"
(UniversitÃ© de Strasbourg - August 2023)

## Practice on the course: [Geometric Transformations on Digital Images](https://indico.math.cnrs.fr/event/9939/sessions/1440/)

Github: [DigitizedRotation_Tutorials-IRMA2023](https://github.com/ngophuc/DigitizedRotation_Tutorials-IRMA2023)

#### **Exercice 1**: a simple program that loads an image and displays it in a window.
"""

#! pip install opencv-python

import cv2 as cv
import os
import matplotlib.pyplot as plt

###################################
########### Main program ##########
###################################

#Test OpenCV version
print("Your OpenCV version is: " + cv.__version__)

cwd = os.getcwd()
print("Current working directory:", cwd)

#TODO: Read an image given the filename
filename = "Samples/church.png"
img = cv.imread(filename, cv.IMREAD_GRAYSCALE)

#TODO: Show the image in the created window
plt.imshow(img, cmap='gray')

#TODO: Save the image
cv.imwrite("Results/save_image.png", img)

"""#### **Exercice 2**: Image rotation with interpolation using an available function in imutils package with OpenCV."""

import cv2 as cv
import os
import matplotlib.pyplot as plt
import math
import imutils
import numpy as np

#Rotation an image with interpolation
def imageRotation(image_in, angle: float):
    #TODO: Rotate the image by the angle (in degree) using imutils package (with interpolation)
    rotated = imutils.rotate(image_in, angle)
    return rotated

###################################
########### Main program ##########
###################################
#Test OpenCV version
print("Your OpenCV version is: " + cv.__version__)

#Get the current directory
cwd = os.getcwd()
print("Current working directory:", cwd)

#Read an image given the filename
#TODO: Change filename here
filename = "Samples/retina.png"
img = cv.imread(FIXME)
#TODO: Show the input image in the window
plt.imshow(FIXME)
plt.show()

#Rotation angle
angle = 45
img_rotated = imageRotation(img, 45)

#TODO: Show the rotated image in the window
plt.imshow(FIXME)
#TODO: Save the rotated image
cv.imwrite("Results/rotated_image.png", img_rotated)

"""#### **Exercice 3**: rotations of point in the continuous space of R^2 and the discrete space of Z^2."""

import math
import numpy as np

#Class of image point in Z2
class ImagePoint:
    row: None  # int
    col: None  # int

    def __init__(self, row_, col_):
        self.row = row_
        self.col = col_

    def __copy__(self):
        return ImagePoint(self.row, self.col)

    def printImagePoint(self):
        print("ImagePoint:(", self.row, ", ", self.col, ")")

#Class of real point in R2
class RealPoint:
    x: None  # int
    y: None  # int

    def __init__(self, x_, y_):
        self.x = x_
        self.y = y_

    def __copy__(self):
        return RealPoint(self.x, self.y)

    def digitizeRealPoint(self) -> ImagePoint:
        return ImagePoint(int(np.round(self.y)), int(np.round(self.x)))

    def printRealPoint(self):
        print("RealPoint:(", self.x, ", ", self.y, ")")

#Class of (forward and backward) rotation for digital image
class rotation:
    theta: None  # float, rotation angle in degree
    center : None # center of rotation
    rotMatrix : None #Rotation matrix from given angle (in degree)

    def __init__(self, angle_):
        self.theta = angle_
        self.center = RealPoint(0,0)
        convert_angle = self.theta * math.pi / 180 #Convert angle from degrees to rads
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def __init__(self, angle_, center_):
        self.theta = angle_
        self.center = center_
        convert_angle = self.theta * math.pi / 180
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def getRotationMatrix(self):
        return self.rotMatrix

    def getInverseRotationMatrix(self):
        #TODO: initize the invers rotation matrix with -angle
        #TODO: initize the rotation matrix from the cos and sin (Indication: do similarly to the previous function)
        invRotMatrix = FIXME
        return invRotMatrix

    def forwardRotation(self, p : RealPoint) -> RealPoint:
        rp = np.array([p.x-self.center.x,p.y-self.center.y]) #Convert the point into an array for multiplication matrix
        rotP = self.rotMatrix.dot(rp) #Apply a multiplication matrix between the point and the rotation matrix
        return RealPoint(rotP[0]+self.center.x, rotP[1]+self.center.y)

    def digitizedForwardRotation(self, p : RealPoint) -> ImagePoint:
        #TODO: apply forwardRotation function on point p
        rp = FIXME
        #TODO: call digitizeRealPoint function for rp to obtain a digitized point
        dp = FIXME
        return dp

    def backwardRotation(self, p : RealPoint) -> RealPoint:
        rp = np.array([p.x-self.center.x,p.y-self.center.y])
        #TODO: call getInverseRotationMatrix function to get the inverser rotation matrix
        rotMatrix = FIXME
        #TODO: apply multiplication matrix between the point pr and the rotation matrix rotMatrix (Indication: do similarly to the forwardRotation function)
        rotP = FIXME
        return RealPoint(rotP[0]+self.center.x, rotP[1]+self.center.y)

    def digitizedBackwardRotation(self, p : RealPoint) -> ImagePoint:
        #TODO: apply backardRotation function on point p
        rp = FIXME
        #TODO: call digitizeRealPoint function for rp to obtain a digitized point
        ip = FIXME
        return ip

###################################
########### Main program ##########
###################################

#TODO: Create a real point of coordinate (5.2, 3.5)
rp = FIXME
#Display the point
rp.printRealPoint()

#TODO: Digitize the created point rp
irp = FIXME
#Display the digitized point
irp.printImagePoint()

#TODO: Create a discret point of coordinate (4, 5)
ip = FIXME
#Display the point
ip.printImagePoint()

#TODO: Create an objet of rotation class for a rotation of 45 degrees with center at RealPoint(0,0)
rot_test = FIXME

#TODO: Forward rotation the real point rp with the previous objet rot_test
rip = FIXME
#Display the point
rip.printRealPoint()

#TODO: Digitized forward rotation the discret point rp
drip = FIXME
#Display the point
drip.printImagePoint()

#TODO: Digitized backward rotation the discret point rp
drip2 = FIXME
#Display the point
drip2.printImagePoint()

"""#### **Exercice 4**: digitized rotation on digital image using the forward and backward models from the previous exercise for points in a digital image."""

import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

#Class of image point in Z2
class ImagePoint:
    row: None  # int
    col: None  # int

    def __init__(self, row_, col_):
        self.row = row_
        self.col = col_

    def __copy__(self):
        return ImagePoint(self.row, self.col)

    def printImagePoint(self):
        print("ImagePoint:(", self.row, ", ", self.col, ")")

#Class of real point in R2
class RealPoint:
    x: None  # int
    y: None  # int

    def __init__(self, x_, y_):
        self.x = x_
        self.y = y_

    def __copy__(self):
        return RealPoint(self.x, self.y)

    def digitizeRealPoint(self) -> ImagePoint:
        return ImagePoint(int(np.round(self.y)), int(np.round(self.x)))

    def printRealPoint(self):
        print("RealPoint:(", self.x, ", ", self.y, ")")

#Class of (forward and backward) rotation for digital image
class rotation:
    angle: None  # float, rotation angle in degree
    center : None # center of rotation
    rotMatrix : None #Rotation matrix from given angle (in degree)

    def __init__(self, angle_):
        self.angle = angle_
        self.center = RealPoint(0,0)
        convert_angle = self.angle*math.pi/180 #Convert angle from degrees to rads
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def __init__(self, angle_, center_):
        self.angle = angle_
        self.center = center_
        convert_angle = self.angle*math.pi/180
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        #TODO: initize the rotation matrix from the cos and sin (Indication: do similarly to the previous function)
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def getRotationMatrix(self):
        return self.rotMatrix

    def getInverseRotationMatrix(self):
        #TODO: initize the invers rotation matrix with -angle
        convert_angle = self.angle*math.pi/180
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        invRotMatrix = np.array([[cos, sin], [-sin, cos]])  #Inverse Rotation matrix an array of floats
        return invRotMatrix

    def forwardRotation(self, p : RealPoint) -> RealPoint:
        rp = np.array([p.x-self.center.x,p.y-self.center.y]) #Convert the point into an array for multiplication matrix
        rotP = self.rotMatrix.dot(rp) #Apply a multiplication matrix between the point and the rotation matrix
        return RealPoint(rotP[0]+self.center.x, rotP[1]+self.center.y)

    def digitizedForwardRotation(self, p : RealPoint) -> ImagePoint:
        #TODO: apply forwardRotation function on point p
        rp = self.forwardRotation(p)
        #TODO: call digitizeRealPoint function for rp to obtain a digitized point
        dp = rp.digitizeRealPoint()
        return dp

    def backwardRotation(self, p : RealPoint) -> RealPoint:
        rp = np.array([p.x-self.center.x,p.y-self.center.y])
        #TODO: call getInverseRotationMatrix function to get the inverser rotation matrix
        rotMatrix = self.getInverseRotationMatrix()
        #TODO: apply multiplication matrix between the point pr and the rotation matrix rotMatrix (Indication: do similarly to the forwardRotation function)
        rotP = rotMatrix.dot(rp)
        return RealPoint(rotP[0]+self.center.x, rotP[1]+self.center.y)

    def digitizedBackwardRotation(self, p : RealPoint) -> ImagePoint:
        #TODO: apply backardRotation function on point p
        rp = self.backwardRotation(p)
        #TODO: call digitizeRealPoint function for rp to obtain a digitized point
        return rp.digitizeRealPoint()

#Function to read the value of a pixel in image
def getPixelValue(img, row : int, col : int) -> int:
    height,width = img.shape[:2] #Get the dimension of the image
    if(row<height and row>=0 and col<width and col>=0):
        return img[row,col]
    return -1
##Function to set a value to a pixel in image
def setPixelValue(img, row : int, col : int, val : int):
    height,width = img.shape[:2]
    if(row<height and row>=0 and col<width and col>=0):
        img[row,col] = val

#Create a black image of size [width, height]
def createBlackImage(width: int, height: int):
    image = np.zeros((height,width,1), np.uint8)
    return image

#Forward rotation of a given image
def forwardRotationImage(image_in, theta):
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #Create a black image to store the transformed result
    image_out = createBlackImage(width,height)
    #TODO: Create an objet of rotation class for the rotation angle theta with center at RealPoint(width/2,height/2)
    rot = FIXME
    #Realized the digitized forward rotation
    for i in range(width):#Col - x
        for j in range(height):#Row - y
            #Get the point in image
            p = RealPoint(i, j)
            #TODO: Call digitizedForwardRotation to transform the point
            rp = FIXME
            #Get the pixel value for the point (i,j) in the image
            v = getPixelValue(image_in, j, i)
            #Set the obtained value to the transformed point
            setPixelValue(image_out, rp.row, rp.col, v)
    #Return the transformed result
    return image_out

#Backward rotation of a given image
def backwardRotationImage(image_in, theta):
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #Create a black image to store the transformed result
    image_out = createBlackImage(width,height)
    #TODO: Create an objet of rotation class for the rotation angle theta with center at RealPoint(width/2,height/2)
    rot = FIXME
    #Realized the digitized backward rotation
    for i in range(width):#Col - x
        for j in range(height):#Row - y
            #Get the point in image
            p = RealPoint(i, j)
            #TODO: call digitizedBackwardRotation to transform the point
            rp = FIXME
            #Get the pixel value for the point (i,j) in the image
            v = getPixelValue(image_in, rp.row, rp.col)
            if(v!=-1): #If the pixel is in the image, then set the value to the point (i,j)
                setPixelValue(image_out, j, i, v)
    #Return the transformed result
    return image_out

###################################
########### Main program ##########
###################################

#Read an image given the filename
#TODO: Change filename here
filename = "Samples/church.png"
img = cv.imread(filename, cv.IMREAD_GRAYSCALE)

#Call forwardRotationImage on the input image img
angle = 45
forward_rot_image = forwardRotationImage(img, angle)
#Display the result
plt.imshow(forward_rot_image, cmap='gray')
plt.show()
#Save the result
cv.imwrite("Results/forward_rotation_image.png", forward_rot_image)

#Call backwardRotationImage on the input image img
backward_rot_image = backwardRotationImage(img, angle)
#Display the result
plt.imshow(backward_rot_image, cmap='gray')
#Save the result
cv.imwrite("Results/backward_rotation_image.png", backward_rot_image)

"""#### **Exercice 5**: Well-composed image verification"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

#Function to read the value of a pixel in image
def getPixelValue(img, row : int, col : int) -> int:
    height,width = img.shape[:2] #Get the dimension of the image
    if(row<height and row>=0 and col<width and col>=0):
        return img[row,col]
    return -1

#Verify whether the four pixels ([a, b], [c, d] form non well-composed configuration
def isFobidenWellComposedConfigutation(a: int, b: int, c: int, d: int) -> bool:
    if(a!=0 and b==0 and c==0 and d!=0):
        return ((a+b)==255 and (c+d)==255) #As in binary image, white pixel = 255

#Verify whether the given image is well-composed (it does not contain forbidden configuration)
def verifyWellComposedImage(image_in) -> bool:
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #Scan the image and check for the forbidden configuration
    for i in range(height-1):#Row
        for j in range(width-1):#Col
            #TODO: Get the four pixels that form a square of 2x2 (Indication: use getPixelValue for the four pixel (i,j), (i+1, j), (i,j+1), (i+1, j+1))
            a = FIXME
            b = FIXME
            c = FIXME
            d = FIXME
            #TODO: Call isFobidenWellComposedConfigutation to detect whether the four pixels form a non well-composed configuration
            if FIXME==True:
                return False #Image is not well-composed
    return True #No forbidden configuration detected, image is well-composed

###################################
########### Main program ##########
###################################

#Read an image given the filename
#TODO: Change filename here
filename = "Samples/circles.png"
img = cv.imread(filename, cv.IMREAD_GRAYSCALE)
#Convert image to a binary image with threshold=125 for example
th_val, img_binary = cv.threshold(img,125,255,cv.THRESH_BINARY)
#Display the input binary image
plt.imshow(img_binary, cmap='gray')
plt.figure()

#TODO: call verifyWellComposedImage to verify the well-composedness of img_binary
is_well_composed = FIXME
#Display the result
if(is_well_composed):
    print("Input image is well-composed")
else:
    print("Input image is not well-composed")

###################################
## Optional: Connected component ##
###################################

#Compute the connected components for 4-connectivity
nb_labels, labels = cv.connectedComponents(img_binary, connectivity=4)

#Map component labels to hue value color
label_hue = np.uint8(1000*labels/np.max(labels))
blank_ch = 255*np.ones_like(label_hue)
labeled_img = cv.merge([label_hue, blank_ch, blank_ch])

#Convert to color image for display
labeled_img = cv.cvtColor(labeled_img, cv.COLOR_HSV2BGR)

#Set background label to black
labeled_img[label_hue==0] = 0

#Display the labelled image
plt.imshow(labeled_img, cmap='hot')
#Save the labelled image
cv.imwrite("Results/labelled_image.png",labeled_img)

"""#### **Exercice 6**: Regularization of well-composed image by upsampling"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

#Create a black image of size [width, height]
def createBlackImage(width: int, height: int):
    image = np.zeros((height,width,1), np.uint8)
    return image

#Function to read the value of a pixel in image
def getPixelValue(img, row : int, col : int) -> int:
    height,width = img.shape[:2] #Get the dimension of the image
    if(row<height and row>=0 and col<width and col>=0):
        return img[row,col]
    return -1
##Function to set a value to a pixel in image
def setPixelValue(img, row : int, col : int, val : int):
    height,width = img.shape[:2]
    if(row<height and row>=0 and col<width and col>=0):
        img[row,col] = val

#Verify whether the four pixels ([a, b], [c, d] form non well-composed configuration
def isFobidenWellComposedConfigutation(a: int, b: int, c: int, d: int) -> bool:
    if(a!=0 and b==0 and c==0 and d!=0):
        return ((a+b)==255 and (c+d)==255) #As in binary image, white pixel = 255

#Verify whether the given image is well-composed (it does not contain forbidden configuration)
def verifyWellComposedImage(image_in) -> bool:
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #Scan the image and check for the forbidden configuration
    for i in range(height-1):#Row
        for j in range(width-1):#Col
            #TODO: Get the four pixels that form a square of 2x2 (Indication: call getPixelValue for the four pixels (i,j), (i+1, j), (i,j+1), (i+1, j+1))
            a = getPixelValue(image_in, i, j)
            b = getPixelValue(image_in, i+1, j)
            c = getPixelValue(image_in, i, j+1)
            d = getPixelValue(image_in, i+1, j+1)
            #TODO: Call isFobidenWellComposedConfigutation to detect whether the four pixels form a non well-composed configuration
            if(isFobidenWellComposedConfigutation(a,b,c,d)==True):
                return False #Image is not well-composed
    return True #No forbidden configuration detected, image is well-composed

#Create a regular image by upsampling a well-composed binary image
def createRegularImage(image_in):
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #TODO: Create an new image of 2 times bigger than image_in (Indication: call createBlackImage for 2*width x 2*height)
    image_upsampling = createBlackImage(2*width, 2*height)
    #Scan the input image, for each white pixel in image_in, make a square of 2x2 pixel in image_upsampling
    for i in range(height-1):#Row
        for j in range(width-1):#Col
            intensity = getPixelValue(image_in, i, j)
            if intensity == 255:#white pixel
                #TODO: Set the color 255 to the 2x2 pixels in image_upsampling (Indication: call setPixelValue for the four pixels (2*i,2*j), (2*i+1, 2*j), (2*i,2*j+1), (2*i+1, 2*j+1))
                FIXME
                FIXME
                FIXME
                FIXME
    return image_upsampling

###################################
########### Main program ##########
###################################

#Read an image given the filename
#TODO: Change filename here
filename = "Samples/retina_wc.png"
img = cv.imread(cv.samples.findFile(filename), cv.IMREAD_GRAYSCALE)
#Convert image to a binary image with threshold=125 for example
th_val, img_binary = cv.threshold(img,125,255,cv.THRESH_BINARY)
#Display the input binary image
plt.imshow(img_binary,cmap='gray')
plt.figure()

#TODO: call verifyWellComposedImage to verify the well-composedness of img_binary
is_well_composed = verifyWellComposedImage(img_binary)
#Display the result
if(is_well_composed):
    print("Input image is well-composed, we regularize the image")
    #TODO: call createRegularImage to regularize the input binary well-composed image
    img_regular = FIXME
    #Display the regular image
    plt.imshow(img_regular,cmap='gray')
    #Save the regular image
    cv.imwrite("Results/regular_image.png",img_regular)
else:
    print("Sorry, the input image is not well-composed!")

"""#### **Exercice 7**: Digitized rotation on regular image"""

import math
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

#Class of image point in Z2
class ImagePoint:
    row: None  # int
    col: None  # int

    def __init__(self, row_, col_):
        self.row = row_
        self.col = col_

    def __copy__(self):
        return ImagePoint(self.row, self.col)

    def printImagePoint(self):
        print("ImagePoint:(", self.row, ", ", self.col, ")")

#Class of real point in R2
class RealPoint:
    x: None  # int
    y: None  # int

    def __init__(self, x_, y_):
        self.x = x_
        self.y = y_

    def __copy__(self):
        return RealPoint(self.x, self.y)

    def digitizeRealPoint(self) -> ImagePoint:
        return ImagePoint(int(np.round(self.y)), int(np.round(self.x)))

    def printRealPoint(self):
        print("RealPoint:(", self.x, ", ", self.y, ")")

#Class of (forward and backward) rotation for digital image
class rotation:
    angle: None  # float, rotation angle in degree
    center : None # center of rotation
    rotMatrix : None #Rotation matrix from given angle (in degree)

    def __init__(self, angle_):
        self.angle = angle_
        self.center = RealPoint(0,0)
        convert_angle = self.angle*math.pi/180 #Convert angle from degrees to rads
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def __init__(self, angle_, center_):
        self.angle = angle_
        self.center = center_
        convert_angle = self.angle*math.pi/180
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        #Initize the rotation matrix from the cos and sin
        self.rotMatrix = np.array([[cos, -sin], [sin, cos]])  #Rotation matrix an array of floats

    def getRotationMatrix(self):
        return self.rotMatrix

    def getInverseRotationMatrix(self):
        #Initize the invers rotation matrix with -angle
        convert_angle = self.angle*math.pi/180
        cos = math.cos(convert_angle)
        sin = math.sin(convert_angle)
        invRotMatrix = np.array([[cos, sin], [-sin, cos]])  #Inverse Rotation matrix an array of floats
        return invRotMatrix

    def backwardRotation(self, p : RealPoint) -> RealPoint:
        rp = np.array([p.x-self.center.x,p.y-self.center.y])
        #Call getInverseRotationMatrix function to get the inverser rotation matrix
        rotMatrix = self.getInverseRotationMatrix()
        #Apply multiplication matrix between the point pr and the rotation matrix rotMatrix
        rotP = rotMatrix.dot(rp)
        return RealPoint(rotP[0]+self.center.x, rotP[1]+self.center.y)

    def digitizedBackwardRotation(self, p : RealPoint) -> ImagePoint:
        #Apply backardRotation function on point p
        rp = self.backwardRotation(p)
        #Call digitizeRealPoint function for rp to obtain a digitized point
        return rp.digitizeRealPoint()

#Function to read the value of a pixel in image
def getPixelValue(img, row : int, col : int) -> int:
    height,width = img.shape[:2] #Get the dimension of the image
    if(row<height and row>=0 and col<width and col>=0):
        return img[row,col]
    return -1
##Function to set a value to a pixel in image
def setPixelValue(img, row : int, col : int, val : int):
    height,width = img.shape[:2]
    if(row<height and row>=0 and col<width and col>=0):
        img[row,col] = val

#Create a black image of size [width, height]
def createBlackImage(width: int, height: int):
    image = np.zeros((height,width,1), np.uint8)
    return image

#Backward rotation of a given image
def backwardRotationImage(image_in, theta):
    #Get dimensions of image
    height, width = image_in.shape[:2]
    #Create a black image to store the transformed result
    image_out = createBlackImage(width,height)
    #Create an objet of rotation class for the rotation theta with center at RealPoint(width/2,height/2)
    rot = rotation(theta, RealPoint(width/2,height/2))
    #Realized the digitized backward rotation
    for i in range(width):#Col - x
        for j in range(height):#Row - y
            #Get the point in image
            p = RealPoint(i, j)
            #Call digitizedBackwardRotation to transform the point
            rp = rot.digitizedBackwardRotation(p)
            #Get the pixel value for the point (i,j) in the image
            v = getPixelValue(image_in, rp.row, rp.col)
            if(v!=-1): #If the pixel is in the image, then set the value to the point (i,j)
                setPixelValue(image_out, j, i, v)
    #Return the transformed result
    return image_out

#Compute the connected components for 4-connectivity
def connectedComponent(image_in):
    #Call connectedComponents function in OpenCV to label the connected component
    nb_labels, labels = cv.connectedComponents(image_in, connectivity=4)
    #Map component labels to hue value color
    label_hue = np.uint8(1000*labels/np.max(labels))
    blank_ch = 255*np.ones_like(label_hue)
    labeled_img = cv.merge([label_hue, blank_ch, blank_ch])
    #Convert to color image for display
    labeled_img = cv.cvtColor(labeled_img, cv.COLOR_HSV2BGR)
    #Set background label to black
    labeled_img[label_hue==0] = 0
    return labeled_img

###################################
########### Main program ##########
###################################

#Read an image given the filename
#TODO: Change filename here
filename = "Samples/retina_wc.png"
img = cv.imread(cv.samples.findFile(filename), cv.IMREAD_GRAYSCALE)

#Call backwardRotationImage on the input image img
angle = 45
backward_rot_image = backwardRotationImage(img, angle)
#Display the result
plt.imshow(backward_rot_image, cmap='gray')
plt.figure()

#Save the result
cv.imwrite("Results/backward_rotation_image.png", backward_rot_image)

#Call the connected component labelling on the transformed image
connected_component_image = connectedComponent(backward_rot_image)
#Display the result
plt.imshow(connected_component_image, cmap='hot')
#Save the result
cv.imwrite("Results/connected_component_image.png", connected_component_image)